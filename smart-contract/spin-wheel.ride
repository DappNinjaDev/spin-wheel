{-# STDLIB_VERSION 3 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

# server public key
let ServerPublicKey = base58'HSP9V7edVKjfLJUfRkEF6vfV9Tyz4Us4yqH9rkwqnHY'
let RouletteSections = 21

let DataGameIdKey = "APP_GAME_ID"

let ErrorOnlyWavesAccepted = "error_only_waves_accepted"

func NewGameId () = {
    let gameNum = match getInteger(this, DataGameIdKey) {
        case num: Int => num
        case _ => 0
    }
    (gameNum + 1)
}

@Callable(i)
func GenerateRandInt (gameId:String, rsaSign:String) = {
    let rsaSigValid = sigVerify(fromBase58String(gameId), fromBase58String(rsaSign), ServerPublicKey);
    if (rsaSigValid) then
    {
        let rand = (toInt(sha256(toBytes(rsaSign))) % RouletteSections)
        #if ((0 > rand))
        #    then (-1 * rand)
        #    else rand

        WriteSet([
            DataEntry("orig", toInt(sha256(toBytes(rsaSign)))),
            DataEntry("rand", rand)
        ])
    }
    else throw("Invalid RSA signature")
}

@Callable(i)
func bet(expectedResult: Int) = {
    let gameNumber = NewGameId()
    let gameId = toBase58String(i.transactionId)
    let pmt = extract(i.payment)

    WriteSet([
            DataEntry("orig", ""),
            DataEntry("rand", "")
        ])
}

@Callable(i)
func bet111(expectedResult: Int) = {
    let lastAuctionIdKey = "last_auction_id"
    let lastAuctionId = match getInteger(this, lastAuctionIdKey) {
                case a:Int => a
                case _ => 0
    }

    let id = lastAuctionId + 1
    let newAuctionId = toString(id)
    let ownerWallet = toBase58String(i.caller.bytes)
    let pmt = value(i.payment)
    if (isDefined(pmt.assetId)) then throw(ErrorOnlyWavesAccepted)
    else {
        let assetId = toBase58String(value(pmt.assetId))
        let auctionDurationKey = "auction_" + newAuctionId + "_duration"
        let auctionMinBidKey = "auction_" + newAuctionId + "_min_bid"
        let auctionLastBidKey = "auction_" + newAuctionId + "_last_bid"
        let auctionLastBidOwnerKey = "auction_" + newAuctionId + "_last_bid_owner"
        let auctionOwnerKey = "auction_" + newAuctionId + "_owner"
        let auctionAmountKey = "auction_" + newAuctionId + "_amount"
        let auctionAssetIdKey = "auction_" + newAuctionId + "_asset_id"
        let auctionIsActiveKey = "auction_" + newAuctionId + "_is_active"
        let userBalanceKey = "balance_" + ownerWallet + "_" + assetId

        let currentAmount = match getInteger(this, userBalanceKey) {
                case a:Int => a
                case _ => 0
        }
        let newAmount = currentAmount + pmt.amount
        WriteSet([
            #DataEntry(auctionDurationKey, height + duration),
            #DataEntry(auctionMinBidKey, minBid),
            DataEntry(auctionLastBidKey, 0),
            DataEntry(auctionOwnerKey, ownerWallet),
            DataEntry(auctionAmountKey, pmt.amount),
            DataEntry(auctionAssetIdKey, assetId),
            DataEntry(userBalanceKey, newAmount),
            DataEntry(auctionIsActiveKey, true),
            DataEntry(auctionLastBidOwnerKey, ""),
            DataEntry(lastAuctionIdKey, id)
        ])
    }
}

@Verifier(tx)
func verify() = if (sigVerify(tx.bodyBytes, getElement(tx.proofs, 0), tx.senderPublicKey))
    then match tx {
        #case ttx: TransferTransaction => ((wavesBalance(this) - ttx.amount) >= 0)
        case stx: SetScriptTransaction =>
            true
        case _ =>
            false
    }
    else false
